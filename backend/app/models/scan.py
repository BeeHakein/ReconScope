"""
Target, Scan, and ScanStatus models.

``Target`` represents a top-level domain submitted for reconnaissance.
``Scan`` captures a single scan execution against a target, including
configuration, progress tracking, aggregated statistics, and relationships
to all discovered assets and analysis results.
"""

from __future__ import annotations

import enum
import uuid
from datetime import datetime, timezone
from typing import TYPE_CHECKING, Optional

from sqlalchemy import (
    DateTime,
    Enum as SQLEnum,
    Float,
    ForeignKey,
    Integer,
    JSON,
    String,
    Text,
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.core.database import Base

if TYPE_CHECKING:
    from app.models.attack_path import AttackPath
    from app.models.correlation import Correlation
    from app.models.finding import Finding
    from app.models.subdomain import Subdomain


class ScanStatus(str, enum.Enum):
    """Lifecycle states for a reconnaissance scan.

    Transitions follow a linear path with an alternate terminal state::

        queued -> running -> post_processing -> completed
                     |                             |
                     +---------> failed <----------+
    """

    QUEUED = "queued"
    RUNNING = "running"
    POST_PROCESSING = "post_processing"
    COMPLETED = "completed"
    FAILED = "failed"


class Target(Base):
    """A domain submitted for attack surface reconnaissance.

    Each unique domain is stored once.  Multiple scans can be associated with
    the same target to track changes over time.

    Attributes:
        id: UUID primary key, auto-generated.
        domain: Fully-qualified domain name (unique, indexed for fast lookup).
        created_at: Timestamp when the target was first registered.
        notes: Optional free-text notes about the target.
        scans: All scans executed against this target.
    """

    __tablename__ = "targets"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
    )
    domain: Mapped[str] = mapped_column(
        String(255),
        unique=True,
        nullable=False,
        index=True,
    )
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
    )
    notes: Mapped[Optional[str]] = mapped_column(
        Text,
        nullable=True,
    )

    # -- Relationships ---------------------------------------------------------
    scans: Mapped[list[Scan]] = relationship(
        "Scan",
        back_populates="target",
        cascade="all, delete-orphan",
        lazy="selectin",
    )

    def __repr__(self) -> str:
        return f"<Target domain={self.domain!r} id={self.id}>"


class Scan(Base):
    """A single scan execution against a :class:`Target`.

    Holds configuration, real-time progress, timing information, aggregated
    statistics, and relationships to every asset and analysis artefact
    discovered during the scan.

    Attributes:
        id: UUID primary key, auto-generated.
        target_id: Foreign key referencing the parent :class:`Target`.
        status: Current lifecycle state (see :class:`ScanStatus`).
        config: JSON blob storing module selection and scan options.
        progress: JSON blob with live progress data (current module, percentage).
        created_at: Timestamp when the scan was queued (indexed for ordering).
        started_at: Timestamp when execution began.
        completed_at: Timestamp when execution finished (success or failure).
        duration_seconds: Wall-clock duration of the scan.
        total_subdomains: Aggregated count of discovered subdomains.
        total_services: Aggregated count of discovered services.
        total_cves: Aggregated count of matched CVEs.
        overall_risk: Computed risk level label (e.g. "critical", "high").
        target: Parent :class:`Target` relationship.
        subdomains: All subdomains discovered in this scan.
        findings: All findings generated by post-processing.
        attack_paths: All inferred attack paths.
        correlations: All correlation insights.
    """

    __tablename__ = "scans"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
    )
    target_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("targets.id", ondelete="CASCADE"),
        nullable=False,
    )
    status: Mapped[ScanStatus] = mapped_column(
        SQLEnum(ScanStatus, name="scan_status", values_callable=lambda e: [v.value for v in e]),
        default=ScanStatus.QUEUED,
        nullable=False,
    )
    config: Mapped[Optional[dict]] = mapped_column(
        JSON,
        default=dict,
        nullable=False,
        server_default="{}",
    )
    progress: Mapped[Optional[dict]] = mapped_column(
        JSON,
        default=dict,
        nullable=False,
        server_default="{}",
    )

    # -- Timing ----------------------------------------------------------------
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        default=lambda: datetime.now(timezone.utc),
        nullable=False,
        index=True,
    )
    started_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
    )
    completed_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
    )
    duration_seconds: Mapped[Optional[float]] = mapped_column(
        Float,
        nullable=True,
    )

    # -- Aggregated Statistics -------------------------------------------------
    total_subdomains: Mapped[int] = mapped_column(
        Integer,
        default=0,
        nullable=False,
        server_default="0",
    )
    total_services: Mapped[int] = mapped_column(
        Integer,
        default=0,
        nullable=False,
        server_default="0",
    )
    total_cves: Mapped[int] = mapped_column(
        Integer,
        default=0,
        nullable=False,
        server_default="0",
    )
    overall_risk: Mapped[Optional[str]] = mapped_column(
        String(20),
        nullable=True,
    )

    # -- Relationships ---------------------------------------------------------
    target: Mapped[Target] = relationship(
        "Target",
        back_populates="scans",
        lazy="joined",
    )
    subdomains: Mapped[list[Subdomain]] = relationship(
        "Subdomain",
        back_populates="scan",
        cascade="all, delete-orphan",
        lazy="selectin",
    )
    findings: Mapped[list[Finding]] = relationship(
        "Finding",
        back_populates="scan",
        cascade="all, delete-orphan",
        lazy="selectin",
    )
    attack_paths: Mapped[list[AttackPath]] = relationship(
        "AttackPath",
        back_populates="scan",
        cascade="all, delete-orphan",
        lazy="selectin",
    )
    correlations: Mapped[list[Correlation]] = relationship(
        "Correlation",
        back_populates="scan",
        cascade="all, delete-orphan",
        lazy="selectin",
    )

    def __repr__(self) -> str:
        return (
            f"<Scan id={self.id} target_id={self.target_id} "
            f"status={self.status.value!r}>"
        )
